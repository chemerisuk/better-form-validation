{
  "name": "better-dom",
  "version": "1.1.0",
  "main": [
    "better-dom.js",
    "better-dom.htc"
  ],
  "ignore": [
    ".*",
    "test",
    "src",
    "extra"
  ],
  "dependencies": {},
  "devDependencies": {
    "jquery": "2.0.2"
  },
  "gitHead": "7e6b961831224b59fc309368c6340e206dc19f3a",
  "readme": "better-dom [![Build Status](https://api.travis-ci.org/chemerisuk/better-dom.png?branch=master)](http://travis-ci.org/chemerisuk/better-dom)\n==========\n> Sandbox for DOM extensions\n\nAPI description: http://chemerisuk.github.io/better-dom/.\n\n## Installation\nThe simplest way is to use [bower](http://bower.io/):\n\n    bower install better-dom\n\nThis will clone the latest version of the library into the `bower_components` directory at the root of your project. Then just include script below on your web page:\n\n```html\n<script src=\"bower_components/build/better-dom.js\" data-htc=\"bower_components/extra/better-dom.htc\"></script>\n```\n\n## Unobtrusive\n`DOM.extend` used to define a new extension and any matched elements will be captured by it. But the coolest thing is that the same will happen even for future content inserted via `innerHTML` or using any other javascript framework.\n\nSo as a developer you don't need to worry about when and how the extension will be initialized. Therefore it's much simpler to create new [extensions](#elastic-textarea-example) or to write [polyfills](#placeholder-polyfill-example) for old browsers.\n\n#### placeholder polyfill example\nThis is a polyfill of the `[placeholder]` attribute for old browsers\n```js\nif (DOM.supports(\"placeholder\", \"input\")) return;\n\nDOM.extend(\"[placeholder]\", [\n    \"input[style='box-sizing: border-box; position: absolute; color: graytext; background: none no-repeat 0 0; border-color: transparent']\"\n], {\n    constructor: function(holder) {\n        var offset = this.offset();\n\n        this\n            .on(\"focus\", holder, \"hide\")\n            .on(\"blur\", this, \"_showPlaceholder\", [holder]);\n\n        holder\n            .set(this.get(\"placeholder\"))\n            .setStyle(\"width\", offset.right - offset.left)\n            .on(\"click\", this, \"fire\", [\"focus\"]);\n\n        if (this.get() || this.isFocused()) holder.hide();\n\n        this.before(holder);\n    },\n    _showPlaceholder: function(holder) {\n        if (!this.get()) holder.show();\n    }\n});\n```\nCheck out [live demo](http://chemerisuk.github.io/better-placeholder-polyfill/) (open in IE < 10, for example).\n\n#### elastic textarea example\nThis is a textarea extension which autoresizes itself to contain all entered text.\n\nCheck out [live demo](http://chemerisuk.github.io/better-elastic-textarea/) and the [extension repository](https://github.com/chemerisuk/better-elastic-textarea).\n\n#### more code: dateinput polyfill\nThe extension makes `input[type=date]` controls with the same UX for all browsers.\n\nCheck out [live demo](http://chemerisuk.github.io/better-dateinput-polyfill) the [extension repository](https://github.com/chemerisuk/better-dateinput-polyfill).\n\n## Event handling best practices\nEvents handling is a big part of writing a code for DOM. And there are some features included into the library APIs that help developers to avoid potential issues and keep their code easier to maintain in future.\n\n#### Get rid of the event object\nEvent callbacks loose the event object argument and it improves testability of code.\n\n```js\n// NOTICE: handler don't have e as the first argument\ninput.on(\"click\", function() {...});\n// NOTICE: event arguments in event name\ninput.on(\"keydown(keyCode,altKey)\", function(keyCode, altKey) {...});\n```\n\n#### Correct return false interpretation\njQuery has strange behavior of event handler that returns false and it's a [cause of confusion](http://fuelyourcoding.com/jquery-events-stop-misusing-return-false/) for a lot of people. This library has standards-based behavior which does what everybody expected.\n\n```js\n// NOTICE: return false prevents ONLY default action\nDOM.find(\"a\").on(\"click\", function() { return false; });\n```\n\n#### Late binding\nUsually an event lintener function is bound when some `addEventListener` method called. This causes trouble when the function value is changed. The library helps to solve the problem by allowing to handle an event using _object property_ instead of just function.\n\n```js\nvar link = DOM.find(\".test-link\"), \n    obj = {handleClick: function() { console.log(\"Hello!\"); }};\n\nlink.on(\"click\", obj, \"handleClick\");\n// every click on the link now logs \"Hello!\" into console\nobj.handleClick = function() { console.log(\"Hello, Maksim!\"); }\n// every click on the link now logs \"Hello, Maksim!\" into console\n```\n\n#### Callback systems are brittle\nThe library doesn't use callback arrays, so any event listener can't break another one (read a [nice article](http://dean.edwards.name/weblog/2009/03/callbacks-vs-events/) for additional details).\n\n```js\nDOM.ready(function() { throw Error(\"exception in a bad code\"); });\n// NOTICE: you'll always see the message in console\nDOM.ready(function() { console.log(\"Nothing can break your code\") });\n```\n\n## Getter and setter\nStandard DOM APIs have a notion of property and attribute for a element. Usually reading a property _is faster_, but a lot of people don't know that or just alway use attributes to keep access the same everywhere in a code.\n\nTo fix this confusion better-dom introduces smart getter and setter.\n\n```js\nvar link = DOM.find(\"#link\");\n\n// returns value of the id property (i.e. \"link\" string)\nlink.get(\"id\");\n// returns value of \"data-attr\" attribute\nlink.get(\"data-attr\");\n// returns innerHTML of the element\nlink.get();\n\n// sets property href (and that action updates attribute value too)\nlink.set(\"href\", \"/some/path\");\n// sets attribute \"data-attr\" to \"123\"\nlink.set(\"data-attr\", \"123\");\n// sets innerHTML to \"some text\"\nlink.set(\"some text\");\n```\n\n## Emmet expressions\nHTML strings are boring and complex, they take a lot of space. Let's fix that with [emmet](http://emmet.io/):\n\n* `nav>ul>li` instead of `<nav><ul><li></li></ul></nav>`\n* `form#search.wide` instead of `<form id=\"search\" class=\"wide\"></form>`\n* `[a='value1' b=\"value2\"]` instead of `<div a=\"value1\" b=\"value2\"></div>`\n* `ul>li.item$*3` instead of `<ul><li class=\"item1\"></li><li class=\"item2\"></li><li class=\"item3\"></li></ul>`\n\nBecause of code size emmet expressions support is only for HTML strings and has some limitations for now, but major features are in place.\n\n\n## Easy localization\nMultilanguage support is often required for an extension. `DOM.importStrings` allows to add a localized string which may be displayed in a html element using `data-i18n` attribute with the appropriate key.\n\n```js\nDOM.importStrings(\"hello.0\", \"Hello!\");\n// NOTICE: optional parameter to specify language of the string\nDOM.importStrings(\"hello.0\", \"Привет!\", \"ru\");\n// element <span data-i18n=\"hello.0\"><span> will display \"Hello!\"\n```\nYou can use parametrized strings via special `{param}` substrings and appropriate `data-*` attributes.\n\n```js\nDOM.importStrings(\"hello.1\", \"Hello {user}!\");\n// element <a data-i18n=\"hello.1\" data-user=\"Maksim\"><a> will display \"Hello Maksim!\"\n```\nTo change a string language manually use setter with `lang` parameter.\n\n```js\nspan.set(\"lang\", \"ru\");\n// now the span displays \"Привет!\"\nDOM.find(\"html\").set(\"lang\", \"ru\");\n// the line changes language globally\n```\n\n## Browser support\n* Chrome\n* Safari\n* Firefox\n* Opera\n* IE8+\n",
  "readmeFilename": "README.md",
  "_id": "better-dom@1.1.0",
  "description": "better-dom [![Build Status](https://api.travis-ci.org/chemerisuk/better-dom.png?branch=master)](http://travis-ci.org/chemerisuk/better-dom) ========== > Sandbox for DOM extensions",
  "repository": {
    "type": "git",
    "url": "git://github.com/chemerisuk/better-dom"
  }
}